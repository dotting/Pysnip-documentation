# Copyright (c) Mathias Kaerlev 2011.# This file is part of pyspades.# pyspades program is free software: you can redistribute it and/or modify# it under the terms of the GNU General Public License as published by# the Free Software Foundation, either version 3 of the License, or# (at your option) any later version.# pyspades is distributed in the hope that it will be useful,# but WITHOUT ANY WARRANTY; without even the implied warranty of# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the# GNU General Public License for more details.# You should have received a copy of the GNU General Public License# along with pyspades.  If not, see <http://www.gnu.org/licenses/>.from pyspades.compression import decompressfrom pyspades.bytereader import ByteReaderfrom pyspades.common import *from pyspades.loaders import *from pyspades import debugSIZES = [0, 8, 48, 44, 8, 4, 6, 8, 24, 8, 12, 10]LOADERS = [    Ack,    ConnectionRequest,    ConnectionResponse,    Disconnect,    Ping,    # packet 6, 7, 8 and 9 are variabled-sized packets    UserInput,    Packet7,    Packet8,    Packet9,    Packet10,    Packet11]for id, loader in enumerate(LOADERS):    loader.id = id + 1class Packet(object):    data = None    timer = None    connectionId = None    packetId = None    unique = None    packets = None    def __init__(self):        pass        def read(self, data, isClient):        debug.isClient = isClient        reader = ByteReader(data)        value = reader.readShort(True)        flags = value & 0xC000        compressed = flags & 0x4000        timer = int(flags & 0x8000 != 0) # has timer?        self.unique = (value >> 12) & 3        self.connectionId = value & 0xFFF # if == 0xFFF CONNECTIONLESS        offset = 2 * timer + 2                if timer:            self.timer = reader.readShort(True)        else:            self.timer = None        if compressed:            decompressedData = decompress(data[offset:])            reader = ByteReader(decompressedData)                self.packets = []                start = reader.tell()                while reader.dataLeft():            value = reader.readByte(True)            packetId = value & 0xF # a should be under 12            byte = reader.readByte()            sequence = reader.readShort(True)            loader = LOADERS[packetId - 1]()            loader.sequence = sequence            loader.read(reader)            self.packets.append(loader)                    reader.seek(start)        self.data = ByteReader(reader.read())        def generate(self):        return ''