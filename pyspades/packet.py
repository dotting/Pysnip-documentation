# Copyright (c) Mathias Kaerlev 2011.# This file is part of pyspades.# pyspades program is free software: you can redistribute it and/or modify# it under the terms of the GNU General Public License as published by# the Free Software Foundation, either version 3 of the License, or# (at your option) any later version.# pyspades is distributed in the hope that it will be useful,# but WITHOUT ANY WARRANTY; without even the implied warranty of# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the# GNU General Public License for more details.# You should have received a copy of the GNU General Public License# along with pyspades.  If not, see <http://www.gnu.org/licenses/>.from pyspades.compression import decompressfrom pyspades.bytereader import ByteReaderfrom pyspades.common import *from pyspades.loaders import *from pyspades import debugSIZES = [0, 8, 48, 44, 8, 4, 6, 8, 24, 8, 12, 10]LOADERS = [    Ack,    ConnectionRequest,    ConnectionResponse,    Disconnect,    Ping,    # packet 6, 7, 8 and 9 are variabled-sized packets    UserInput,    Packet7,    MapData,    Packet9,    Packet10,    Packet11]for id, loader in enumerate(LOADERS):    loader.id = id + 1class Packet(object):    data = None    timer = None    connectionId = None    packetId = None    unique = None    packets = None    def __init__(self):        pass        def read(self, data, isClient):        reader = ByteReader(data)        value = reader.readShort(True)        flags = value & 0xC000        compressed = flags & 0x4000        timer = int(flags & 0x8000 != 0) # has timer?        self.unique = (value >> 12) & 3        self.connectionId = value & 0xFFF # if == 0xFFF CONNECTIONLESS        offset = 2 * timer + 2                if timer:            self.timer = reader.readShort(True)        else:            self.timer = None                if compressed:            decompressedData = decompress(data[offset:])            reader = ByteReader(decompressedData)                self.packets = []                start = reader.tell()                while reader.dataLeft():            value = reader.readByte(True)            packetId = value & 0xF # a should be under 12            byte = reader.readByte(True)            sequence = reader.readShort(True)            loader = LOADERS[packetId - 1]()            loader.ack = (value & 0x80) != 0            loader.sequence = sequence            loader.byte = byte            loader.read(reader)            self.packets.append(loader)                    reader.seek(start)        self.data = ByteReader(reader.read())        def generate(self):        reader = ByteReader()        flags = 0        if self.timer is not None:            flags |= 0x8000        connectionId = self.connectionId        if connectionId is None:            connectionId = 0xFFF        unique = self.unique        if unique is None:            unique = 0        value = flags | ((unique & 3) << 12) | (connectionId & 0xFFF)        reader.writeShort(value, True)        if self.timer is not None:            reader.writeShort(self.timer, True)        start = reader.tell()        for packet in self.packets:            packetId = packet.id            if packet.ack:                packetId |= 0x80            reader.writeByte(packetId, True)            reader.writeByte(packet.byte or 0, True)            reader.writeShort(packet.sequence or 0, True)            packet.write(reader)        return reader